#!/usr/bin/env python3
"""
rsudp Health Check Monitor

This script monitors the health of rsudp by checking the health.json file
generated by the HealthChecker module. It returns exit code 0 for healthy
status and -1 for unhealthy status.

Usage:
    python healthz.py [--health-file PATH] [--timeout SECONDS] [--verbose]

Exit codes:
    0  : rsudp is healthy
    -1 : rsudp is unhealthy or health file issues
"""

import argparse
import json
import sys
from datetime import datetime, timezone
from pathlib import Path


class HealthMonitor:
    """Health monitoring class for rsudp."""

    def __init__(self, health_file_path=None, timeout=300, verbose=False):
        """
        Initialize the health monitor.

        :param str health_file_path: Path to the health.json file
        :param int timeout: Maximum seconds since last data before considering unhealthy
        :param bool verbose: Enable verbose output
        """
        self.health_file = health_file_path or self._find_health_file()
        self.timeout = timeout
        self.verbose = verbose

    def _find_health_file(self):
        """
        Find the health.json file in common locations.

        :return: Path to health.json file
        :rtype: str
        """
        possible_paths = [
            "/opt/rsudp/data/health.json",
            "./data/health.json",
        ]

        for path in possible_paths:
            expanded_path = Path(path).expanduser()
            if expanded_path.exists():
                if self.verbose:
                    self._log(f"Found health file at: {expanded_path}")
                return str(expanded_path)

        # Default to /opt/rsudp/data/health.json if not found
        return "/opt/rsudp/data/health.json"

    def _log(self, message):
        """Log message if verbose mode is enabled."""
        if self.verbose:
            timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            sys.stdout.write(f"[{timestamp}] {message}\n")
            sys.stdout.flush()

    def check_health(self):
        """
        Check the health status of rsudp.

        :return: True if healthy, False otherwise
        :rtype: bool
        """
        try:
            return self._perform_health_check()
        except json.JSONDecodeError as e:
            self._log(f"Invalid JSON in health file: {e}")
            return False
        except FileNotFoundError:
            self._log(f"Health file not found: {self.health_file}")
            return False
        except PermissionError:
            self._log(f"Permission denied reading health file: {self.health_file}")
            return False
        except Exception as e:
            self._log(f"Unexpected error checking health: {e}")
            return False

    def _perform_health_check(self):
        """Perform the actual health check logic."""
        health_path = Path(self.health_file)

        # Check if health file exists
        if not health_path.exists():
            self._log(f"Health file not found: {self.health_file}")
            return False

        # Check file age
        file_stat = health_path.stat()
        file_age = datetime.now(timezone.utc).timestamp() - file_stat.st_mtime

        if file_age > self.timeout:
            self._log(f"Health file is too old: {file_age:.1f} seconds (timeout: {self.timeout}s)")
            return False

        # Read and parse health file
        with health_path.open() as f:
            health_data = json.load(f)

        return self._validate_health_data(health_data)

    def _validate_health_data(self, health_data):
        """Validate the health data structure and content."""
        # Validate basic structure
        required_keys = ["timestamp", "status", "threads", "statistics", "last_activity"]
        for key in required_keys:
            if key not in health_data:
                self._log(f"Missing required key in health data: {key}")
                return False

        # Check status
        if health_data["status"] != "healthy":
            self._log(f"Status is not healthy: {health_data['status']}")
            return False

        return self._check_timestamps(health_data) and self._check_thread_activity(health_data)

    def _check_timestamps(self, health_data):
        """Check timestamp freshness and data activity."""
        now = datetime.now(timezone.utc)

        # Check timestamp freshness
        try:
            health_timestamp = datetime.fromisoformat(health_data["timestamp"].replace("Z", "+00:00"))
            age_seconds = (now - health_timestamp).total_seconds()

            if age_seconds > self.timeout:
                self._log(f"Health timestamp is too old: {age_seconds:.1f} seconds")
                return False

        except (ValueError, KeyError) as e:
            self._log(f"Invalid timestamp in health data: {e}")
            return False

        # Check if data is being received
        last_data = health_data["last_activity"].get("last_data_received")
        if not last_data:
            self._log("No data has been received yet")
            return False

        try:
            last_data_time = datetime.fromisoformat(last_data.replace("Z", "+00:00"))
            data_age = (now - last_data_time).total_seconds()

            if data_age > self.timeout:
                self._log(f"Last data received too long ago: {data_age:.1f} seconds")
                return False

        except (ValueError, KeyError) as e:
            self._log(f"Invalid last_data_received timestamp: {e}")
            return False

        return True

    def _check_thread_activity(self, health_data):
        """Check thread activity and log statistics."""
        # Check thread activity
        threads = health_data["threads"]
        if not threads.get("health_active", False):
            self._log("Health thread is not active")
            return False

        # Log statistics if verbose
        if self.verbose:
            self._log_statistics(health_data)

        self._log("rsudp is healthy")
        return True

    def _log_statistics(self, health_data):
        """Log detailed statistics if verbose mode is enabled."""
        stats = health_data["statistics"]
        threads = health_data["threads"]

        self._log(
            f"Statistics: packets={stats.get('data_packets_received', 0)}, "
            f"alerts={stats.get('alert_events_detected', 0)}, "
            f"errors={stats.get('error_count', 0)}"
        )

        self._log(
            f"Thread status: health={threads.get('health_active')}, "
            f"alert={threads.get('alert_active')}, "
            f"plot={threads.get('plot_active')}, "
            f"writer={threads.get('writer_active')}"
        )

        uptime = health_data.get("uptime_seconds", 0)
        self._log(f"Uptime: {uptime} seconds ({uptime / 3600:.1f} hours)")


def main():
    """Monitor rsudp health status via command line."""
    parser = argparse.ArgumentParser(description="Monitor rsudp health status")
    parser.add_argument(
        "--health-file", "-f", help="Path to health.json file (auto-detected if not specified)"
    )
    parser.add_argument(
        "--timeout",
        "-t",
        type=int,
        default=300,
        help="Timeout in seconds for considering data stale (default: 300)",
    )
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")

    args = parser.parse_args()

    # Create health monitor
    monitor = HealthMonitor(health_file_path=args.health_file, timeout=args.timeout, verbose=args.verbose)

    # Check health
    is_healthy = monitor.check_health()

    # Exit with appropriate code
    if is_healthy:
        sys.exit(0)  # Healthy
    else:
        sys.exit(1)  # Changed to 1 instead of -1 for better shell compatibility


if __name__ == "__main__":
    main()
