--- a/rsudp/c_plots.py	2026-01-06 01:03:32.600049363 +0900
+++ b/rsudp/c_plots.py	2026-01-06 01:08:59.951667273 +0900
@@ -3,7 +3,7 @@
 import time
 import math
 import numpy as np
-from datetime import datetime, timedelta
+from datetime import datetime, timedelta, timezone
 from obspy.signal.trigger import recursive_sta_lta, trigger_onset
 import rsudp.raspberryshake as rs
 from rsudp import printM, printW, printE, get_scap_dir, helpers
@@ -16,21 +16,29 @@
 PhotoImage = False
 try:
     from matplotlib import use
-    try:
-        use('Qt5Agg')
-        from PyQt5 import QtGui
-        QT = True
-    except Exception as e:
-        printW('Qt import failed. Trying Tk...')
-        printW('detail: %s' % e, spaces=True)
+
+    if os.environ.get('DISPLAY') is None:
+        use('Agg')  # Headless environment
+    else:
         try:
-            use('TkAgg')
-            from tkinter import PhotoImage
+            use('Qt5Agg')
+            from PyQt5 import QtGui
+
+            QT = True
         except Exception as e:
-            printE('Could not import either Qt or Tk, and the plot module requires at least one of them to run.', sender)
-            printE('Please make sure either PyQt5 or Tkinter is installed.', sender, spaces=True)
-            printE('detail: %s'% e, sender, spaces=True)
-            raise ImportError('Could not import either Qt or Tk, and the plot module requires at least one of them to run')
+            printW('Qt import failed. Trying Tk...')
+            printW('detail: %s' % e, spaces=True)
+            try:
+                use('TkAgg')
+                from tkinter import PhotoImage
+            except Exception as e:
+                printE(
+                    'Could not import either Qt or Tk, and the plot module requires at least one of them to run.',
+                    sender,
+                )
+                printE('Please make sure either PyQt5 or Tkinter is installed.', sender, spaces=True)
+                printE('detail: %s' % e, sender, spaces=True)
+                raise ImportError('Could not import either Qt or Tk, and the plot module requires at least one of them to run')
     import matplotlib.pyplot as plt
     import matplotlib.dates as mdates
     import matplotlib.image as mpimg
@@ -178,13 +186,16 @@
         '''
         helpers.deconvolve(self)

-    def savefig(self, event_time=rs.UTCDateTime.now(), event_time_str=rs.UTCDateTime.now().strftime('%Y-%m-%d-%H%M%S')):
+    def savefig(self, event_time=rs.UTCDateTime.now(), event_time_str=rs.UTCDateTime.now().strftime('%Y-%m-%d-%H%M%S'), sta_val=None, lta_val=None, max_count=None):
         '''
         Saves the figure and puts an IMGPATH message on the master queue.
         This message can be used to upload the image to various services.

         :param obspy.core.utcdatetime.UTCDateTime event_time: Event time as an obspy UTCDateTime object. Defaults to ``UTCDateTime.now()``.
         :param str event_time_str: Event time as a string, in the format ``'%Y-%m-%d-%H%M%S'``. This is used to set the filename.
+        :param float sta_val: STA value at trigger time. If provided, will be embedded in PNG metadata.
+        :param float lta_val: LTA value at trigger time. If provided, will be embedded in PNG metadata.
+        :param int max_count: Maximum count value at trigger time. If provided, will be embedded in PNG metadata.
         '''
         with self.screenshot_lock:
             scap_dir = get_scap_dir()  # Get screenshot directory
@@ -192,8 +203,22 @@
             elapsed = rs.UTCDateTime.now() - event_time
             if int(elapsed) > 0:
                 printM(f'Saving png {int(elapsed)} seconds after alarm', sender=self.sender)
+
+            # Prepare metadata for PNG
+            metadata = {}
+            if sta_val is not None and lta_val is not None:
+                desc = f'STA={sta_val:.6f}, LTA={lta_val:.6f}, STA/LTA={sta_val/lta_val if lta_val != 0 else 0:.6f}'
+                if max_count is not None:
+                    desc += f', MaxCount={max_count}'
+                metadata['Description'] = desc
+                metadata['Comment'] = f'Trigger STA/LTA values at {event_time_str}'
+                printM(f'Embedding STA/LTA metadata: STA={sta_val:.6f}, LTA={lta_val:.6f}', sender=self.sender)
+                if max_count is not None:
+                    metadata['EHZ_MaxCount'] = str(max_count)
+                    printM(f'Embedding EHZ max count: {max_count}', sender=self.sender)
+
             try:
-                plt.savefig(figname, facecolor=self.fig.get_facecolor(), edgecolor='none')
+                plt.savefig(figname, facecolor=self.fig.get_facecolor(), edgecolor='none', metadata=metadata)
             except Exception as e:
                 printE(f'Error saving png image: {e}', sender=self.sender)
                 return
@@ -376,23 +401,31 @@
         self.spectrogram = spectrogram
         printM('Starting.', self.sender)

-    def _eventsave(self, event_time):
+    def _eventsave(self, event_time, sta_val=None, lta_val=None, max_count=None):
         '''
         This function takes the next event in line and pops it out of the list,
         so that it can be saved and others preserved.
         Then, it sets the title to something having to do with the event,
         then calls the save figure function, and finally resets the title.
+
+        :param obspy.core.utcdatetime.UTCDateTime event_time: Event time
+        :param float sta_val: STA value at trigger time (optional)
+        :param float lta_val: LTA value at trigger time (optional)
+        :param int max_count: Maximum count value at trigger time (optional)
         '''
         # format strings
         event_time_str = event_time.strftime('%Y-%m-%d-%H%M%S')  # for filename
-        title_time_str = event_time.strftime('%Y-%m-%d %H:%M:%S.%f')[:22]  # for title
+        # Convert to JST (UTC+9)
+        jst_tz = timezone(timedelta(hours=9))
+        event_time_jst = event_time.datetime.replace(tzinfo=timezone.utc).astimezone(jst_tz)
+        title_time_str = event_time_jst.strftime('%Y-%m-%d %H:%M:%S.%f')[:22]  # for title

         # temporarily set title for this event
-        self.fig.suptitle(f'{self.stn} Detected Event - {title_time_str} UTC',
-                        fontsize=14, color=self.fgcolor, x=0.52)
+        self.fig.suptitle(f'{self.stn} Detected Event - {title_time_str} JST',
+                        fontsize=18, color=self.fgcolor, x=0.52, y=0.99)

-        # save the figure
-        self.savefig(event_time=event_time, event_time_str=event_time_str)
+        # save the figure with STA/LTA metadata
+        self.savefig(event_time=event_time, event_time_str=event_time_str, sta_val=sta_val, lta_val=lta_val, max_count=max_count)

         # reset the title
         self.set_fig_title(self.events)
@@ -757,18 +790,34 @@
             self.save_timer -= 1  # don't push the save time forward if there are a large number of alarm events
             event = [self.save_timer + int(self.save_pct * self.pkts_in_period),
                      helpers.fsec(helpers.get_msg_time(d))]  # event = [save after count, datetime]
-            self.last_event_str = '%s UTC' % (event[1].strftime('%Y-%m-%d %H:%M:%S.%f')[:22])
+            # Convert to JST for display
+            jst_tz = timezone(timedelta(hours=9))
+            event_jst = event[1].datetime.replace(tzinfo=timezone.utc).astimezone(jst_tz)
+            self.last_event_str = '%s JST' % (event_jst.strftime('%Y-%m-%d %H:%M:%S.%f')[:22])
             printM('Event time: %s' % (self.last_event_str), sender=self.sender)  # show event time in the logs
+
+            # Extract STA/LTA values and max count from ALARM message
+            sta_lta_values = helpers.get_msg_sta_lta(d)
+            max_count = helpers.get_msg_max_count(d)
+
             if self.screencap:
                 printM('Saving png in about %i seconds' % (self.save_pct * (self.seconds)), self.sender)
                 event_time = helpers.fsec(helpers.get_msg_time(d))
-                self.save.append({
+                event_info = {
                     'save_at': time.time() + int(self.save_pct * self.seconds),
                     'event_time': event_time
-                })  # append the event to the save list
+                }
+                # Include STA/LTA values if available
+                if sta_lta_values is not None:
+                    event_info['sta_val'] = sta_lta_values[0]
+                    event_info['lta_val'] = sta_lta_values[1]
+                # Include max count value if available
+                if max_count is not None:
+                    event_info['max_count'] = max_count
+                self.save.append(event_info)  # append the event to the save list
             self.fig.suptitle('Raspberry Shake %s Live Data - Detected Events: %s'  # title
                               % (self.stn, self.events),
-                              fontsize=14, color=self.fgcolor, x=0.52)
+                              fontsize=18, color=self.fgcolor, x=0.52, y=0.99)
             self.fig.canvas.manager.set_window_title('(%s) %s - Raspberry Shake Monitor' % (self.events, self.stn))

         if rs.getCHN(d) in self.chans:
@@ -850,7 +899,11 @@
             ready = [e for e in self.save if now >= e['save_at']]
             self.save = [e for e in self.save if now < e['save_at']]  # keep only future ones
             for e in ready:
-                self._eventsave(event_time=e['event_time'])
+                # Pass STA/LTA values and max_count if available
+                sta_val = e.get('sta_val')
+                lta_val = e.get('lta_val')
+                max_count = e.get('max_count')
+                self._eventsave(event_time=e['event_time'], sta_val=sta_val, lta_val=lta_val, max_count=max_count)

         u = 0
         time.sleep(0.005)  # wait a ms to see if another packet will arrive
