diff --git a/rsudp/c_liveness.py b/rsudp/c_liveness.py
new file mode 100644
index 0000000..577480f
--- /dev/null
+++ b/rsudp/c_liveness.py
@@ -0,0 +1,121 @@
+import os
+import time
+from threading import Thread
+from rsudp import printM, printW, printE
+
+
+class Liveness(Thread):
+    """
+    Thread to periodically touch a liveness file to indicate the application is running.
+    """
+    
+    def __init__(self, liveness_file='/dev/shm/rsudp.liveness', interval=5, testing=False,
+                 threads_to_monitor=None, controller=None):
+        """
+        Initialize the Liveness thread.
+        
+        :param str liveness_file: Path to the liveness file
+        :param int interval: Interval in seconds between updates
+        :param bool testing: Testing mode flag
+        :param list threads_to_monitor: List of threads to monitor
+        :param PlotsController controller: PlotsController instance to monitor
+        """
+        super().__init__()
+        self.sender = 'Liveness'
+        self.alive = True
+        self.alarm = False
+        self.alarm_reset = False
+        self.testing = testing
+        self.liveness_file = liveness_file
+        self.interval = interval
+        self.threads_to_monitor = threads_to_monitor or []
+        self.controller = controller
+        self.last_controller_heartbeat = time.time() if controller else None
+        
+        printM('Starting liveness monitor (file: %s, interval: %ds, monitoring %d threads%s)' % 
+               (self.liveness_file, self.interval, len(self.threads_to_monitor),
+                ' + PlotsController' if self.controller else ''), self.sender)
+    
+    def _check_threads(self):
+        """
+        Check if all monitored threads are still alive.
+        
+        :return: True if all threads are alive, False otherwise
+        :rtype: bool
+        """
+        # Check regular threads
+        for thread in self.threads_to_monitor:
+            if hasattr(thread, 'alive') and not thread.alive:
+                printE('Thread %s is not alive' % thread.__class__.__name__, self.sender)
+                return False
+            elif not thread.is_alive():
+                printE('Thread %s has stopped' % thread.__class__.__name__, self.sender)
+                return False
+        
+        # Check PlotsController (runs in main thread)
+        if self.controller:
+            # Check if controller has heartbeat attribute and is responsive
+            if hasattr(self.controller, 'heartbeat'):
+                heartbeat_age = time.time() - self.controller.heartbeat
+                # If heartbeat is older than 2 intervals, consider it dead
+                if heartbeat_age > self.interval * 2:
+                    printE('PlotsController heartbeat is stale (%.1fs old)' % heartbeat_age, self.sender)
+                    return False
+            # Also check the alive flag
+            if hasattr(self.controller, 'alive') and not self.controller.alive:
+                printE('PlotsController is not alive', self.sender)
+                return False
+        
+        return True
+    
+    def _touch_file(self):
+        """
+        Touch the liveness file to update its modification time.
+        Only touches the file if all monitored components are healthy.
+        """
+        # First check if all threads are healthy
+        if not self._check_threads():
+            printW('Not updating liveness file - some components are not healthy', self.sender)
+            return False
+        
+        try:
+            # Create parent directory if it doesn't exist
+            os.makedirs(os.path.dirname(self.liveness_file), exist_ok=True)
+            
+            # Touch the file
+            with open(self.liveness_file, 'a'):
+                os.utime(self.liveness_file, None)
+            return True
+        except Exception as e:
+            printW('Failed to update liveness file: %s' % str(e), self.sender)
+            return False
+    
+    def run(self):
+        """
+        Main loop to periodically update the liveness file.
+        """
+        printM('Liveness monitor started', self.sender)
+        
+        # Initial touch to create the file
+        self._touch_file()
+        
+        while self.alive:
+            # Sleep in small intervals to allow quick shutdown
+            for _ in range(self.interval * 10):
+                if not self.alive:
+                    break
+                time.sleep(0.1)
+            
+            # Update liveness file only if still alive and all threads are healthy
+            if self.alive:
+                self._touch_file()
+        
+        # Clean up the liveness file on shutdown
+        try:
+            if os.path.exists(self.liveness_file):
+                os.remove(self.liveness_file)
+                printM('Liveness file removed', self.sender)
+        except Exception as e:
+            printW('Failed to remove liveness file: %s' % str(e), self.sender)
+        
+        printM('Liveness monitor stopped', self.sender)
\ No newline at end of file
diff --git a/rsudp/c_plot_controller.py b/rsudp/c_plot_controller.py
index b54c8ab..4d104ee 100644
--- a/rsudp/c_plot_controller.py
+++ b/rsudp/c_plot_controller.py
@@ -25,6 +25,7 @@ class PlotsController():
 
         self.sender = 'PlotsController'
         self.alive = True
+        self.heartbeat = time.time()  # Add heartbeat for liveness monitoring
         self.save_timer = 0
         self.refresh_interval = refresh_interval
         self.delay = rs.tr if (self._plots[0].spectrogram) else 1
@@ -63,13 +64,24 @@ class PlotsController():
         n = 0  # number of iterations without plotting
         i = 0  # number of plot events without clearing the linecache
         u = -1  # number of blocked queue calls (must be -1 at startup)
+        last_heartbeat_update = time.time()  # track last heartbeat update time
         while True:  # main loop
             refresh_start = time.time()
+            # Update heartbeat every 2 seconds to ensure it stays fresh
+            current_time = time.time()
+            if current_time - last_heartbeat_update > 2:
+                self.heartbeat = current_time
+                last_heartbeat_update = current_time
             while True:  # sub loop
                 if self.alive == False:  # break if the user has closed the plot
                     break
                 n += 1
                 self.save_timer += 1
+                # Update heartbeat in inner loop too
+                current_time = time.time()
+                if current_time - last_heartbeat_update > 2:
+                    self.heartbeat = current_time
+                    last_heartbeat_update = current_time
                 if self.queue.qsize() > 0:
                     self.get_queue()
                     time.sleep(0.009)  # wait a ms to see if another packet will arrive
diff --git a/rsudp/client.py b/rsudp/client.py
index 6911dc8..bb09dc3 100644
--- a/rsudp/client.py
+++ b/rsudp/client.py
@@ -27,6 +27,7 @@ from rsudp.c_rsam import RSAM
 from rsudp.c_testing import Testing
 from rsudp.t_testdata import TestData
 from rsudp.c_settings import Settings
+from rsudp.c_liveness import Liveness
 import pkg_resources as pr
 
 
@@ -412,6 +413,9 @@ def run(settings, debug):
 		test = Testing(q=q)
 		mk_p(test)
 
+	# Create liveness monitor thread with threads to monitor and PlotsController if available
+	liveness = Liveness(testing=TESTING, threads_to_monitor=THREADS, controller=CONTROLLER if CONTROLLER else None)
+	mk_p(liveness)
 
 	# start the producer, consumer, and activated modules
 	start()
