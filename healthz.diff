diff --git a/rsudp/__init__.py b/rsudp/__init__.py
index 1234567..abcdefg 100644
--- a/rsudp/__init__.py
+++ b/rsudp/__init__.py
@@ -31,6 +31,7 @@ TIME_FORMAT = '%Y-%m-%d %H:%M:%S'
 
 output_dir = False
 data_dir = False
+health_file = False
 scap_dir = False
 ms_path = False
 
@@ -249,3 +250,10 @@ def printE(msg, sender='', announce=True, spaces=False):
 	# strip emoji from unicode by converting to ascii
 	msg = msg.encode('ascii', 'ignore').decode('ascii')
 	LOG.error(msg)
+
+def get_health_file():
+	"""
+	Returns the health check file location.
+	"""
+	global health_file
+	return health_file if health_file else os.path.join(get_data_dir(), 'health.json')
diff --git a/rsudp/c_health.py b/rsudp/c_health.py
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/rsudp/c_health.py
@@ -0,0 +1,162 @@
+import os
+import json
+import time
+import threading
+from datetime import datetime, timezone
+import rsudp.raspberryshake as rs
+from rsudp import printM, printW, printE, get_health_file
+
+
+class HealthChecker(rs.ConsumerThread):
+	"""
+	A health monitoring class that periodically writes system health status
+	to a JSON file. This allows external monitoring systems to check if
+	rsudp is functioning properly.
+	
+	:param queue.Queue q: queue of data and messages sent by :class:`rsudp.c_consumer.Consumer`
+	:param int interval: interval in seconds between health updates (default: 30)
+	:param bool testing: whether or not we are in testing mode
+	"""
+	
+	def __init__(self, q, interval=30, testing=False):
+		"""
+		Initialize the health checker.
+		"""
+		super().__init__()
+		self.sender = 'Health'
+		self.alive = True
+		self.testing = testing
+		self.q = q
+		
+		self.interval = interval
+		self.health_file = get_health_file()
+		self.lock = threading.Lock()
+		
+		# Health status tracking
+		self.last_data_time = None
+		self.last_alert_time = None
+		self.last_image_time = None
+		self.alert_count = 0
+		self.data_packet_count = 0
+		self.error_count = 0
+		self.start_time = datetime.now(timezone.utc)
+		
+		printM(f'Health checker initialized, writing to {self.health_file}', self.sender)
+		
+		# Start the periodic health file writer
+		self.writer_thread = threading.Thread(target=self._periodic_writer, daemon=True)
+		self.writer_thread.start()
+	
+	def _periodic_writer(self):
+		"""
+		Periodically write health status to file.
+		"""
+		while self.alive:
+			try:
+				self._write_health_status()
+				time.sleep(self.interval)
+			except Exception as e:
+				printE(f'Health writer error: {e}', self.sender)
+				time.sleep(self.interval)
+	
+	def _write_health_status(self):
+		"""
+		Write current health status to the health file.
+		"""
+		try:
+			with self.lock:
+				now = datetime.now(timezone.utc)
+				uptime_seconds = (now - self.start_time).total_seconds()
+				
+				health_data = {
+					'timestamp': now.isoformat(),
+					'uptime_seconds': int(uptime_seconds),
+					'status': 'healthy',
+					'threads': {
+						'health_active': self.alive,
+						'alert_active': self._is_alert_active(),
+						'plot_active': self._is_plot_active(),
+						'writer_active': self._is_writer_active(),
+						'rsam_active': self._is_rsam_active()
+					},
+					'statistics': {
+						'data_packets_received': self.data_packet_count,
+						'alert_events_detected': self.alert_count,
+						'error_count': self.error_count
+					},
+					'last_activity': {
+						'last_data_received': self.last_data_time.isoformat() if self.last_data_time else None,
+						'last_earthquake_detection': self.last_alert_time.isoformat() if self.last_alert_time else None,
+						'last_image_saved': self.last_image_time.isoformat() if self.last_image_time else None
+					}
+				}
+				
+				# Write to temporary file first, then atomic rename
+				temp_file = self.health_file + '.tmp'
+				os.makedirs(os.path.dirname(self.health_file), exist_ok=True)
+				with open(temp_file, 'w') as f:
+					json.dump(health_data, f, indent=2)
+				os.rename(temp_file, self.health_file)
+				
+		except Exception as e:
+			printE(f'Failed to write health status: {e}', self.sender)
+			self.error_count += 1
+	
+	def _is_alert_active(self):
+		"""Check if alert thread is actually running."""
+		try:
+			from rsudp.client import THREADS
+			from rsudp.c_alert import Alert
+			
+			for thread in THREADS:
+				if isinstance(thread, Alert) and thread.is_alive():
+					return True
+		except ImportError:
+			pass
+		return False
+	
+	def _is_plot_active(self):
+		"""Check if plot controller/thread is active."""
+		try:
+			from rsudp.client import CONTROLLER, THREADS
+			from rsudp.c_plots import Plot, PlotAlert
+			
+			# Check if CONTROLLER exists (it runs in main thread, so check if it's not None)
+			if CONTROLLER is not None:
+				return True
+			
+			# Also check for Plot or PlotAlert threads
+			for thread in THREADS:
+				if isinstance(thread, (Plot, PlotAlert)) and thread.is_alive():
+					return True
+		except ImportError:
+			pass
+		return False
+	
+	def _is_writer_active(self):
+		"""Check if writer thread is active."""
+		try:
+			from rsudp.client import WRITER
+			
+			if WRITER and WRITER.is_alive():
+				return True
+		except ImportError:
+			pass
+		return False
+	
+	def _is_rsam_active(self):
+		"""Check if RSAM thread is active."""
+		try:
+			from rsudp.client import THREADS
+			from rsudp.c_rsam import RSAM
+			
+			for thread in THREADS:
+				if isinstance(thread, RSAM) and thread.is_alive():
+					return True
+		except ImportError:
+			pass
+		return False
+	
+	def run(self):
+		"""
+		Main loop - processes messages from the queue and updates health statistics.
+		"""
+		while True:
+			d = self.getq()
+			
+			now = datetime.now(timezone.utc)
+			
+			if 'TERM' in str(d):
+				self.alive = False
+				break
+			elif 'ALARM' in str(d):
+				with self.lock:
+					self.alert_count += 1
+					self.last_alert_time = now
+			elif 'IMGPATH' in str(d):
+				with self.lock:
+					self.last_image_time = now
+			elif rs.getCHN(d):
+				with self.lock:
+					self.data_packet_count += 1
+					self.last_data_time = now
+
diff --git a/rsudp/client.py b/rsudp/client.py
index 1234567..abcdefg 100644
--- a/rsudp/client.py
+++ b/rsudp/client.py
@@ -27,6 +27,7 @@ from rsudp.c_rsam import RSAM
 from rsudp.c_testing import Testing
 from rsudp.t_testdata import TestData
 from rsudp.c_settings import Settings
+from rsudp.c_health import HealthChecker
 import pkg_resources as pr
 
 
@@ -399,6 +400,13 @@ def run(settings, debug):
 
 		mk_p(rsam)
 
+	# Health monitoring
+	if settings.get('health', {}).get('enabled', True):
+		interval = settings.get('health', {}).get('interval', 30)
+		q = mk_q()
+		health = HealthChecker(q=q, interval=interval, testing=TESTING)
+		mk_p(health)
+		printM('Health monitoring enabled', sender=SENDER)
 
 	# start additional modules here!
 	################################
