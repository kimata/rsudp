diff --git a/rsudp/c_alert.py b/rsudp/c_alert.py
index faf7abf..3d39863 100644
--- a/rsudp/c_alert.py
+++ b/rsudp/c_alert.py
@@ -300,6 +300,35 @@ class Alert(rs.ConsumerThread):
 																			 trigger_onset(self.stalta, self.thresh,
 																						   self.reset)[-1][0] *
 																			 self.stream[0].stats.delta))
+		
+		# Calculate STA and LTA values at trigger time
+		trigger_index = int(len(self.stalta) - 1)  # Index of the trigger point
+		data_len = len(self.stream[0].data)
+		
+		# Calculate STA and LTA windows
+		sta_samples = int(self.sta * self.sps)
+		lta_samples = int(self.lta * self.sps)
+		
+		if trigger_index >= sta_samples and data_len >= lta_samples:
+			# Calculate STA value (short term average)
+			sta_start = max(0, trigger_index - sta_samples)
+			sta_end = trigger_index
+			sta_data = self.stream[0].data[sta_start:sta_end]
+			sta_val = np.sqrt(np.mean(sta_data**2)) if len(sta_data) > 0 else 0.0
+			
+			# Calculate LTA value (long term average)
+			lta_start = max(0, trigger_index - lta_samples)
+			lta_end = trigger_index
+			lta_data = self.stream[0].data[lta_start:lta_end]
+			lta_val = np.sqrt(np.mean(lta_data**2)) if len(lta_data) > 0 else 0.0
+			
+			# Store STA/LTA values for use by the alarm message
+			self.trigger_sta_val = sta_val
+			self.trigger_lta_val = lta_val
+		else:
+			self.trigger_sta_val = None
+			self.trigger_lta_val = None
+		
 		print()
 		printM('Trigger threshold of %s exceeded at %s'
 			   % (self.thresh, self.alarm.strftime('%Y-%m-%d %H:%M:%S.%f')[:22]), self.sender)
diff --git a/rsudp/c_plots.py b/rsudp/c_plots.py
index 9c44a1c..2187ba2 100644
--- a/rsudp/c_plots.py
+++ b/rsudp/c_plots.py
@@ -189,13 +189,15 @@ class AbcPlot():
         '''
         helpers.deconvolve(self)
 
-    def savefig(self, event_time=rs.UTCDateTime.now(), event_time_str=rs.UTCDateTime.now().strftime('%Y-%m-%d-%H%M%S')):
+    def savefig(self, event_time=rs.UTCDateTime.now(), event_time_str=rs.UTCDateTime.now().strftime('%Y-%m-%d-%H%M%S'), sta_val=None, lta_val=None):
         '''
         Saves the figure and puts an IMGPATH message on the master queue.
         This message can be used to upload the image to various services.
 
         :param obspy.core.utcdatetime.UTCDateTime event_time: Event time as an obspy UTCDateTime object. Defaults to ``UTCDateTime.now()``.
         :param str event_time_str: Event time as a string, in the format ``'%Y-%m-%d-%H%M%S'``. This is used to set the filename.
+        :param float sta_val: STA value at trigger time. If provided, will be embedded in PNG metadata.
+        :param float lta_val: LTA value at trigger time. If provided, will be embedded in PNG metadata.
         '''
         with self.screenshot_lock:
             scap_dir = get_scap_dir()  # Get screenshot directory
@@ -203,8 +205,16 @@ class AbcPlot():
             elapsed = rs.UTCDateTime.now() - event_time
             if int(elapsed) > 0:
                 printM(f'Saving png {int(elapsed)} seconds after alarm', sender=self.sender)
+            
+            # Prepare metadata for PNG
+            metadata = {}
+            if sta_val is not None and lta_val is not None:
+                metadata['Description'] = f'STA={sta_val:.6f}, LTA={lta_val:.6f}, STA/LTA={sta_val/lta_val if lta_val != 0 else 0:.6f}'
+                metadata['Comment'] = f'Trigger STA/LTA values at {event_time_str}'
+                printM(f'Embedding STA/LTA metadata: STA={sta_val:.6f}, LTA={lta_val:.6f}', sender=self.sender)
+            
             try:
-                plt.savefig(figname, facecolor=self.fig.get_facecolor(), edgecolor='none')          
+                plt.savefig(figname, facecolor=self.fig.get_facecolor(), edgecolor='none', metadata=metadata)          
             except Exception as e:
                 printE(f'Error saving png image: {e}', sender=self.sender)
                 return
@@ -387,12 +397,16 @@ class Plot(AbcPlot):
         self.spectrogram = spectrogram
         printM('Starting.', self.sender)
 
-    def _eventsave(self, event_time):
+    def _eventsave(self, event_time, sta_val=None, lta_val=None):
         '''
         This function takes the next event in line and pops it out of the list,
         so that it can be saved and others preserved.
         Then, it sets the title to something having to do with the event,
         then calls the save figure function, and finally resets the title.
+        
+        :param obspy.core.utcdatetime.UTCDateTime event_time: Event time
+        :param float sta_val: STA value at trigger time (optional)
+        :param float lta_val: LTA value at trigger time (optional)
         '''
         # format strings
         event_time_str = event_time.strftime('%Y-%m-%d-%H%M%S')  # for filename
@@ -402,8 +416,8 @@ class Plot(AbcPlot):
         self.fig.suptitle(f'{self.stn} Detected Event - {title_time_str} UTC',
                         fontsize=14, color=self.fgcolor, x=0.52)
 
-        # save the figure
-        self.savefig(event_time=event_time, event_time_str=event_time_str)
+        # save the figure with STA/LTA metadata
+        self.savefig(event_time=event_time, event_time_str=event_time_str, sta_val=sta_val, lta_val=lta_val)
 
         # reset the title
         self.set_fig_title(self.events)
@@ -772,13 +786,22 @@ class Plot(AbcPlot):
                      helpers.fsec(helpers.get_msg_time(d))]  # event = [save after count, datetime]
             self.last_event_str = '%s UTC' % (event[1].strftime('%Y-%m-%d %H:%M:%S.%f')[:22])
             printM('Event time: %s' % (self.last_event_str), sender=self.sender)  # show event time in the logs
+            
+            # Extract STA/LTA values from ALARM message
+            sta_lta_values = helpers.get_msg_sta_lta(d)
+            
             if self.screencap:
                 printM('Saving png in about %i seconds' % (self.save_pct * (self.seconds)), self.sender)
                 event_time = helpers.fsec(helpers.get_msg_time(d))
-                self.save.append({
+                event_info = {
                     'save_at': time.time() + int(self.save_pct * self.seconds),
                     'event_time': event_time
-                })  # append the event to the save list
+                }
+                # Include STA/LTA values if available
+                if sta_lta_values is not None:
+                    event_info['sta_val'] = sta_lta_values[0]
+                    event_info['lta_val'] = sta_lta_values[1]
+                self.save.append(event_info)  # append the event to the save list
             self.fig.suptitle('Raspberry Shake %s Live Data - Detected Events: %s'  # title
                               % (self.stn, self.events),
                               fontsize=14, color=self.fgcolor, x=0.52)
@@ -863,7 +886,10 @@ class Plot(AbcPlot):
             ready = [e for e in self.save if now >= e['save_at']]
             self.save = [e for e in self.save if now < e['save_at']]  # keep only future ones
             for e in ready:
-                self._eventsave(event_time=e['event_time'])
+                # Pass STA/LTA values if available
+                sta_val = e.get('sta_val')
+                lta_val = e.get('lta_val')
+                self._eventsave(event_time=e['event_time'], sta_val=sta_val, lta_val=lta_val)
         
         u = 0
         time.sleep(0.005)  # wait a ms to see if another packet will arrive
diff --git a/rsudp/helpers.py b/rsudp/helpers.py
index d23fa85..64da868 100644
--- a/rsudp/helpers.py
+++ b/rsudp/helpers.py
@@ -133,7 +133,7 @@ def conn_stats(TESTING=False):
 			   sender=s, announce=False)
 
 
-def msg_alarm(event_time):
+def msg_alarm(event_time, sta_val=None, lta_val=None):
 	'''
 	This function constructs the ``ALARM`` message as a bytes object.
 	Currently this is only used by :py:class:`rsudp.p_producer.Producer`
@@ -148,11 +148,24 @@ def msg_alarm(event_time):
 		>>> msg_alarm(ti)
 		b'ALARM 2020-01-01T00:00:00.599Z'
 
+	With STA/LTA values:
+
+	.. code-block:: python
+
+		>>> msg_alarm(ti, 0.5, 0.25)
+		b'ALARM 2020-01-01T00:00:00.599Z STA=0.500000 LTA=0.250000'
+
 	:param obspy.core.utcdatetime.UTCDateTime event_time: the datetime object to serialize and convert to bytes
+	:param float sta_val: Short Term Average value at trigger time (optional)
+	:param float lta_val: Long Term Average value at trigger time (optional)
 	:rtype: bytes
 	:return: the ``ALARM`` message, ready to be put on the queue
 	'''
-	return b'ALARM %s' % bytes(str(event_time), 'utf-8')
+	base_msg = b'ALARM %s' % bytes(str(event_time), 'utf-8')
+	if sta_val is not None and lta_val is not None:
+		sta_lta_info = b' STA=%f LTA=%f' % (sta_val, lta_val)
+		return base_msg + sta_lta_info
+	return base_msg
 
 
 def msg_reset(reset_time):
@@ -266,6 +279,43 @@ def get_msg_path(msg):
 	return msg.decode('utf-8').split(' ')[2]
 
 
+def get_msg_sta_lta(msg):
+	'''
+	This function extracts STA and LTA values from ``ALARM`` messages.
+
+	For example:
+
+	.. code-block:: python
+
+		>>> from obspy import UTCDateTime
+		>>> ti = UTCDateTime(2020, 1, 1, 0, 0, 0, 599000, precision=3)
+		>>> msg = msg_alarm(ti, 0.5, 0.25)
+		>>> get_msg_sta_lta(msg)
+		(0.5, 0.25)
+
+	:param bytes msg: the bytes-formatted ``ALARM`` message to decode
+	:rtype: tuple or None
+	:return: (sta_val, lta_val) tuple if STA/LTA values are present, None otherwise
+
+	'''
+	msg_str = msg.decode('utf-8')
+	if 'STA=' in msg_str and 'LTA=' in msg_str:
+		try:
+			parts = msg_str.split(' ')
+			sta_val = None
+			lta_val = None
+			for part in parts:
+				if part.startswith('STA='):
+					sta_val = float(part.split('=')[1])
+				elif part.startswith('LTA='):
+					lta_val = float(part.split('=')[1])
+			if sta_val is not None and lta_val is not None:
+				return (sta_val, lta_val)
+		except (ValueError, IndexError):
+			pass
+	return None
+
+
 def deconv_vel_inst(self, trace, output):
 	'''
 	.. role:: pycode(code)
diff --git a/rsudp/p_producer.py b/rsudp/p_producer.py
index 7fd07a2..96324fd 100644
--- a/rsudp/p_producer.py
+++ b/rsudp/p_producer.py
@@ -64,9 +64,15 @@ class Producer(Thread):
 			# for each thread here
 			if thread.alarm:
 				# if there is an alarm in a sub thread, send the ALARM message to the queues
-				self.queue.put(helpers.msg_alarm(thread.alarm))
+				# Include STA/LTA values if available from the alert thread
+				sta_val = getattr(thread, 'trigger_sta_val', None)
+				lta_val = getattr(thread, 'trigger_lta_val', None)
+				self.queue.put(helpers.msg_alarm(thread.alarm, sta_val, lta_val))
 				printM('%s thread has indicated alarm state, sending ALARM message to queues'
 						% thread.sender, sender=self.sender)
+				if sta_val is not None and lta_val is not None:
+					printM('Including STA/LTA values: STA=%.6f, LTA=%.6f'
+							% (sta_val, lta_val), sender=self.sender)
 				# now re-arm the trigger
 				thread.alarm = False
 			if thread.alarm_reset:
diff --git a/rsudp/c_alert.py b/rsudp/c_alert.py
index 3d39863..0b4c6dd 100644
--- a/rsudp/c_alert.py
+++ b/rsudp/c_alert.py
@@ -325,9 +325,20 @@ class Alert(rs.ConsumerThread):
 			# Store STA/LTA values for use by the alarm message
 			self.trigger_sta_val = sta_val
 			self.trigger_lta_val = lta_val
+			
+			# Calculate max count value for EHZ channel at trigger time
+			if self.cha == 'EHZ' or (self.cha == 'all' and 'EHZ' in rs.chns):
+				# Get the maximum absolute value around the trigger point
+				window_start = max(0, trigger_index - sta_samples)
+				window_end = min(data_len, trigger_index + sta_samples)
+				window_data = self.stream[0].data[window_start:window_end]
+				self.trigger_max_count = int(np.max(np.abs(window_data))) if len(window_data) > 0 else 0
+			else:
+				self.trigger_max_count = None
 		else:
 			self.trigger_sta_val = None
 			self.trigger_lta_val = None
+			self.trigger_max_count = None
 		
 		print()
 		printM('Trigger threshold of %s exceeded at %s'
diff --git a/rsudp/c_plots.py b/rsudp/c_plots.py
index 2514bd7..6500baf 100644
--- a/rsudp/c_plots.py
+++ b/rsudp/c_plots.py
@@ -198,7 +198,7 @@ class AbcPlot():
         '''
         helpers.deconvolve(self)
 
-    def savefig(self, event_time=rs.UTCDateTime.now(), event_time_str=rs.UTCDateTime.now().strftime('%Y-%m-%d-%H%M%S'), sta_val=None, lta_val=None):
+    def savefig(self, event_time=rs.UTCDateTime.now(), event_time_str=rs.UTCDateTime.now().strftime('%Y-%m-%d-%H%M%S'), sta_val=None, lta_val=None, max_count=None):
         '''
         Saves the figure and puts an IMGPATH message on the master queue.
         This message can be used to upload the image to various services.
@@ -207,6 +207,7 @@ class AbcPlot():
         :param str event_time_str: Event time as a string, in the format ``'%Y-%m-%d-%H%M%S'``. This is used to set the filename.
         :param float sta_val: STA value at trigger time. If provided, will be embedded in PNG metadata.
         :param float lta_val: LTA value at trigger time. If provided, will be embedded in PNG metadata.
+        :param int max_count: Maximum count value for EHZ channel at trigger time. If provided, will be embedded in PNG metadata.
         '''
         with self.screenshot_lock:
             scap_dir = get_scap_dir()  # Get screenshot directory
@@ -218,9 +219,15 @@ class AbcPlot():
             # Prepare metadata for PNG
             metadata = {}
             if sta_val is not None and lta_val is not None:
-                metadata['Description'] = f'STA={sta_val:.6f}, LTA={lta_val:.6f}, STA/LTA={sta_val/lta_val if lta_val != 0 else 0:.6f}'
+                desc = f'STA={sta_val:.6f}, LTA={lta_val:.6f}, STA/LTA={sta_val/lta_val if lta_val != 0 else 0:.6f}'
+                if max_count is not None:
+                    desc += f', MaxCount={max_count}'
+                metadata['Description'] = desc
                 metadata['Comment'] = f'Trigger STA/LTA values at {event_time_str}'
                 printM(f'Embedding STA/LTA metadata: STA={sta_val:.6f}, LTA={lta_val:.6f}', sender=self.sender)
+                if max_count is not None:
+                    metadata['EHZ_MaxCount'] = str(max_count)
+                    printM(f'Embedding EHZ max count: {max_count}', sender=self.sender)
             
             try:
                 plt.savefig(figname, facecolor=self.fig.get_facecolor(), edgecolor='none', metadata=metadata)          
@@ -406,7 +413,7 @@ class Plot(AbcPlot):
         self.spectrogram = spectrogram
         printM('Starting.', self.sender)
 
-    def _eventsave(self, event_time, sta_val=None, lta_val=None):
+    def _eventsave(self, event_time, sta_val=None, lta_val=None, max_count=None):
         '''
         This function takes the next event in line and pops it out of the list,
         so that it can be saved and others preserved.
@@ -416,6 +423,7 @@ class Plot(AbcPlot):
         :param obspy.core.utcdatetime.UTCDateTime event_time: Event time
         :param float sta_val: STA value at trigger time (optional)
         :param float lta_val: LTA value at trigger time (optional)
+        :param int max_count: Maximum count value for EHZ channel at trigger time (optional)
         '''
         # format strings
         event_time_str = event_time.strftime('%Y-%m-%d-%H%M%S')  # for filename
@@ -429,7 +437,7 @@ class Plot(AbcPlot):
                         fontsize=18, color=self.fgcolor, x=0.52, y=0.99)
 
         # save the figure with STA/LTA metadata
-        self.savefig(event_time=event_time, event_time_str=event_time_str, sta_val=sta_val, lta_val=lta_val)
+        self.savefig(event_time=event_time, event_time_str=event_time_str, sta_val=sta_val, lta_val=lta_val, max_count=max_count)
 
         # reset the title
         self.set_fig_title(self.events)
@@ -814,6 +822,8 @@ class Plot(AbcPlot):
             
             # Extract STA/LTA values from ALARM message
             sta_lta_values = helpers.get_msg_sta_lta(d)
+            # Extract max count value from ALARM message
+            max_count = helpers.get_msg_max_count(d)
             
             if self.screencap:
                 printM('Saving png in about %i seconds' % (self.save_pct * (self.seconds)), self.sender)
@@ -826,6 +836,9 @@ class Plot(AbcPlot):
                 if sta_lta_values is not None:
                     event_info['sta_val'] = sta_lta_values[0]
                     event_info['lta_val'] = sta_lta_values[1]
+                # Include max count value if available
+                if max_count is not None:
+                    event_info['max_count'] = max_count
                 self.save.append(event_info)  # append the event to the save list
             self.fig.suptitle('Raspberry Shake %s Live Data - Detected Events: %s'  # title
                               % (self.stn, self.events),
@@ -914,7 +927,8 @@ class Plot(AbcPlot):
                 # Pass STA/LTA values if available
                 sta_val = e.get('sta_val')
                 lta_val = e.get('lta_val')
-                self._eventsave(event_time=e['event_time'], sta_val=sta_val, lta_val=lta_val)
+                max_count = e.get('max_count')
+                self._eventsave(event_time=e['event_time'], sta_val=sta_val, lta_val=lta_val, max_count=max_count)
         
         u = 0
         time.sleep(0.005)  # wait a ms to see if another packet will arrive
diff --git a/rsudp/client.py b/rsudp/client.py
index ad1e116..bb09dc3 100644
--- a/rsudp/client.py
+++ b/rsudp/client.py
@@ -413,8 +413,8 @@ def run(settings, debug):
 		test = Testing(q=q)
 		mk_p(test)
 
-	# Start liveness monitor thread
-	liveness = Liveness(testing=TESTING)
+	# Create liveness monitor thread with threads to monitor and PlotsController if available
+	liveness = Liveness(testing=TESTING, threads_to_monitor=THREADS, controller=CONTROLLER if CONTROLLER else None)
 	mk_p(liveness)
 
 	# start the producer, consumer, and activated modules
diff --git a/rsudp/helpers.py b/rsudp/helpers.py
index 64da868..bb9e64f 100644
--- a/rsudp/helpers.py
+++ b/rsudp/helpers.py
@@ -133,7 +133,7 @@ def conn_stats(TESTING=False):
 			   sender=s, announce=False)
 
 
-def msg_alarm(event_time, sta_val=None, lta_val=None):
+def msg_alarm(event_time, sta_val=None, lta_val=None, max_count=None):
 	'''
 	This function constructs the ``ALARM`` message as a bytes object.
 	Currently this is only used by :py:class:`rsudp.p_producer.Producer`
@@ -155,17 +155,27 @@ def msg_alarm(event_time, sta_val=None, lta_val=None):
 		>>> msg_alarm(ti, 0.5, 0.25)
 		b'ALARM 2020-01-01T00:00:00.599Z STA=0.500000 LTA=0.250000'
 
+	With STA/LTA and max count values:
+
+	.. code-block:: python
+
+		>>> msg_alarm(ti, 0.5, 0.25, 1234)
+		b'ALARM 2020-01-01T00:00:00.599Z STA=0.500000 LTA=0.250000 COUNT=1234'
+
 	:param obspy.core.utcdatetime.UTCDateTime event_time: the datetime object to serialize and convert to bytes
 	:param float sta_val: Short Term Average value at trigger time (optional)
 	:param float lta_val: Long Term Average value at trigger time (optional)
+	:param int max_count: Maximum count value for EHZ channel at trigger time (optional)
 	:rtype: bytes
 	:return: the ``ALARM`` message, ready to be put on the queue
 	'''
 	base_msg = b'ALARM %s' % bytes(str(event_time), 'utf-8')
+	extra_info = b''
 	if sta_val is not None and lta_val is not None:
-		sta_lta_info = b' STA=%f LTA=%f' % (sta_val, lta_val)
-		return base_msg + sta_lta_info
-	return base_msg
+		extra_info += b' STA=%f LTA=%f' % (sta_val, lta_val)
+	if max_count is not None:
+		extra_info += b' COUNT=%d' % max_count
+	return base_msg + extra_info
 
 
 def msg_reset(reset_time):
@@ -316,6 +326,37 @@ def get_msg_sta_lta(msg):
 	return None
 
 
+def get_msg_max_count(msg):
+	'''
+	This function extracts the max count value from ``ALARM`` messages.
+
+	For example:
+
+	.. code-block:: python
+
+		>>> from obspy import UTCDateTime
+		>>> ti = UTCDateTime(2020, 1, 1, 0, 0, 0, 599000, precision=3)
+		>>> msg = msg_alarm(ti, 0.5, 0.25, 1234)
+		>>> get_msg_max_count(msg)
+		1234
+
+	:param bytes msg: the bytes-formatted ``ALARM`` message to decode
+	:rtype: int or None
+	:return: max_count value if present, None otherwise
+
+	'''
+	msg_str = msg.decode('utf-8')
+	if 'COUNT=' in msg_str:
+		try:
+			parts = msg_str.split(' ')
+			for part in parts:
+				if part.startswith('COUNT='):
+					return int(part.split('=')[1])
+		except (ValueError, IndexError):
+			pass
+	return None
+
+
 def deconv_vel_inst(self, trace, output):
 	'''
 	.. role:: pycode(code)
diff --git a/rsudp/p_producer.py b/rsudp/p_producer.py
index 96324fd..032c22e 100644
--- a/rsudp/p_producer.py
+++ b/rsudp/p_producer.py
@@ -67,12 +67,15 @@ class Producer(Thread):
 				# Include STA/LTA values if available from the alert thread
 				sta_val = getattr(thread, 'trigger_sta_val', None)
 				lta_val = getattr(thread, 'trigger_lta_val', None)
-				self.queue.put(helpers.msg_alarm(thread.alarm, sta_val, lta_val))
+				max_count = getattr(thread, 'trigger_max_count', None)
+				self.queue.put(helpers.msg_alarm(thread.alarm, sta_val, lta_val, max_count))
 				printM('%s thread has indicated alarm state, sending ALARM message to queues'
 						% thread.sender, sender=self.sender)
 				if sta_val is not None and lta_val is not None:
 					printM('Including STA/LTA values: STA=%.6f, LTA=%.6f'
 							% (sta_val, lta_val), sender=self.sender)
+				if max_count is not None:
+					printM('Including EHZ max count: %d' % max_count, sender=self.sender)
 				# now re-arm the trigger
 				thread.alarm = False
 			if thread.alarm_reset:
